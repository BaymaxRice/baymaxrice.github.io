~~~go
### 背景

go语言中，可以在runtime源码中看到string类型和 slice 类型的数据结构：

```go
// string 类型
type stringStruct struct {
	str unsafe.Pointer
	len int
}

// [] 类型
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

两个结构类型，切片只是比string类型多了一个cap

### 问题

在go语言中，如果想修改string类型的数据，需要先将string转成对应的[]byte或[]rune等可变类型，然后修改其中的某些数据，之后再转化回来。但是不管如何转化，都需要重新分配内存，复制数据来实现。可通过以下步骤验证：

```go
s := "hello world"
fmt.Printf("s: %p, %#v\n", &s, s)
fmt.Printf("s: %p, %#v\n", unsafe.Pointer((*reflect.StringHeader)(unsafe.Pointer(&s)).Data), s)

byteS := []byte(s)
fmt.Printf("byteS: %p, %#v\n", &byteS, byteS)
fmt.Printf("byteS: %p, %#v\n", unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(&byteS)).Data), byteS)

stringS := string(byteS)
fmt.Printf("stringS: %p, %#v\n", &stringS, stringS)
fmt.Printf("stringS: %p, %#v\n\n", unsafe.Pointer((*reflect.StringHeader)(unsafe.Pointer(&stringS)).Data), stringS)
```

对应的执行结果为：

```
s: 0xc00007c030, "hello world"
s: 0x10c8da4, "hello world"
byteS: 0xc000088000, []byte{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64}
byteS: 0xc00008a000, []byte{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64}
stringS: 0xc000092000, "hello world"
stringS: 0xc00008a010, "hello world"
```

可以看到每次转换类型之后，内存的地址都发生了变化，不管是变量的地址，还是真正数据的地址。这种转变操作有时候会非常的拖累算法性能，可以通过使用一些“非安全”的方法来进行改善

```go
afterStr := *(*[]byte)(unsafe.Pointer(&s))
undoStr := *(*string)(unsafe.Pointer(&afterStr))

fmt.Printf("afterStr: %p, %#v\n", &afterStr, afterStr)
fmt.Printf("afterStr: %p, %#v\n", unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(&afterStr)).Data), afterStr)
fmt.Printf("undoStr: %p, %#v\n", &undoStr, undoStr)
fmt.Printf("undoStr: %p, %#v\n", unsafe.Pointer((*reflect.StringHeader)(unsafe.Pointer(&undoStr)).Data), undoStr)
```

对应的执行结果为：

```
afterStr: 0xc000090020, []byte{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64}
afterStr: 0x10c8da4, []byte{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64}
undoStr: 0xc00007c070, "hello world"
undoStr: 0x10c8da4, "hello world"
```

可以发现，变量的地址一直会变化，但是强转类型之后的真正数据结构里面存储字符串的地址却没有发生变化。



考虑到字符串的只读特征，转换时候复制数据到新内存是可以理解的。但是性能也同样重要，所以编译器会在一些场合进行一些优化，避免额外的分配和复制操作：

- 将 []byte 转换为 string key，去map[string]查询的时候
- 将string转换为 []byte，去for range的时候，直接取字节赋值给局部变量

```go
func main() {
	m := map[string]int{
		"abc":123,
	}

	key := []byte("abc")
	x, ok := m[string(key)]

	fmt.Println(x, ok)
}
```

使用GDB来验证一下：（自己GDB有问题，后续再验证）
~~~